# -*- coding: utf-8 -*-
"""WebApp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tZgmwIdJhIzuNh0rryfCJNOM-PFsqnx5

# Creare una WebApp in Python utilizzando le API Rest... per esempi!

Metodologia generale

## WebApp
Una applicazione web (web application in inglese, abbreviato web app o WebApp), in informatica ed in particolare nella programmazione web, indica genericamente tutte le applicazioni distribuite ovvero applicazioni accessibili/fruibili via web per mezzo di un network, come ad esempio una Intranet all'interno di un sistema informatico o attraverso internet, cioè in una architettura tipica di tipo client-server, offrendo determinati servizi all'utente client.

## L’importanza del Browser
OS + Browser (software tutto fare)

## HTML5 CSS3 Javascript Ajax

Software standalone
Atom is a free and open-source text and source code editor for macOS, Linux, and Microsoft Windows with support for plug-ins written in Node.js, and embedded Git Control, developed by GitHub. Atom is a desktop application built using web technologies.[8] Most of the extending packages have free software licenses and are community-built and maintained.[9] Atom is based on Electron (formerly known as Atom Shell), a framework that enables cross-platform desktop applications using Chromium and Node.js. It is written in CoffeeScript and Less.
Atom è un editor di testo e IDE open source e sviluppato da GitHub, rilasciato nel 2014. Esso è basato su Chromium ed è scritto in CoffeeScript, il che gli permette di essere eseguito su qualsiasi piattaforma supportata da Chromium.

## Vantaggi (rilasci centralizzato) e svantaggi (non “poggia” direttamente sull’OS)!

## Le Web App
Sicuramente tutti voi abbiate avuto a che fare con una Web App senza saperlo. Un esempio? Quando si naviga nella versione mobile di un sito web, si sta utilizzando una Web App.

web app
Questa infatti funziona esattamente come un sito web. Poco importa il sistema operativo del dispositivo, lo sviluppo, il linguaggio di programmazione ecc. Tutte le distinzioni fatte nel paragrafo precedente tra iOS e Android non vi interesseranno. Tant’è vero che gli utenti non dovranno neanche installarla sul proprio smartphone.

Questa tipologia di App, nata con lo scopo di rendere un contenuto web disponibile anche per dispositivi mobili, ha i suoi principali punti di forza nel:

-	non richiedere alcuno spazio di memoria per l’installazione o il download;
-	poter essere realizzata con costi molto bassi e in poco tempo.
Sono ben più numerosi i suoi punti deboli:

-	non può funzionare senza Internet;
-	si adatta meno a ciascun sistema operativo (iOS o Android), non essendo disegnata su misura per nessuno dei due;
-	non è disponibile sugli store, il che ne rende impossibile il download;
-	non è (sarebbe) possibile inviare Notifiche Push agli utenti.
A seconda delle proprie esigenze, questa soluzione può rivelarsi la scelta più giusta per semplicità di realizzazione e costi, anche se piuttosto limitata nell’utilizzo.

## Le App
Quando si pensa ad un’App non si sta pensando quasi mai ad una Web App.
Le applicazioni con cui abbiamo a che fare tutti i giorni molto spesso non rientrano in questa categoria. Le App del nostro quotidiano si differenziano dalle Web App soprattutto per quanto riguarda gli alti costi e i più lunghi tempi di realizzazione. Ciò è dovuto ad una serie di plus di cui difficilmente riusciamo a fare a meno:
•	velocità e affidabilità. Sono sicuramente componenti immancabili in un’App classica, sviluppata ad hoc per il sistema operativo del dispositivo su cui verranno utilizzate;
•	accesso immediato ed efficace a tutte le funzionalità del telefono (fotocamera, microfono, accelerometro). Per il motivo di cui sopra;
•	possibilità di inviare Notifiche Push agli utenti;
•	può essere presente sugli store;
•	non necessita di connessione a Internet per funzionare.
È per questo che un’App classica richiede una buona quantità di spazio disponibile sul proprio dispositivo per essere installata.

## App o Web App. La soluzione giusta
Qualunque siano le proprie esigenze, è chiaro quanto sia importante valutare attentamente le proprie necessità prima di compiere una scelta.
Se vi è capitato di chiedervi quanto possa costare un’App, ora sapete che è più opportuno chiedersi prima: “di quale tipologia di applicazione ho bisogno?”.

## Problema da risolvere
O necessità che vogliamo direttamente o indirettamente che venga soddisfatta.
## Ingredienti
-	Linguaggio semplice e potente, particolarmente orientato al problem solving.
-	Conoscenza dei linguaggi del WEB (HTML5, CSS3, Javascript, Ajax, …).
-	Conoscenza dell’architettura del WEB e rudimenti di reti (architettura Client Server, protocolli HTTP(S)).
-	Fonti a pagamento oppure no (tramite analisi, scraping o quant’altro). Librerie per gestire i dati di scambio ([JSON](https://www.json.org/json-it.html), XML, CSV, custom...).
-	Infrastruttura HW/SW (anche un semplice pc o SBPC come il raspberry) per l’erogazione del servizio.

## Cuoco
Il programmatore che realizza l’algoritmo risolutivo tradotto in codice.

# Python
![alt text](https://www.python.org/static/opengraph-icon-200x200.png "Logo Python")

## Popolarità
Attualmente risulta essere il linguaggio più popolare (usato?) - I linguaggi di programmazione più popolari 1965 - 2019
https://www.youtube.com/watch?v=Og847HVwRSI

## Perché?
Il linguaggio più utilizzato in ambito sistemistico. Lo usano anche i Web Debveloper per il backend dei siti (Flask, Django, Web2py), i Data Scientist per l'analisi dei dati (Numpy, Pandas, Scipy, Matplotlib), i Game Developer (PyGame), i Mobile Developer (Kivy) e tutti per generaere documentazione (Sphinx).

## Caratteristiche principali
Linguaggio ad **alto livello interpretato**, **orientato agli oggetti**, **opensource**, **multipiattaforma** (HW/SW):

- Introdotto a partire dal 1991 dall'olandese Guido Van Rossum.
- Fortemente tipizzato, con type checking a run time.
- Leggibilità è una caratteristica propria della sua sintassi.
- Ispirato al Monty Python's Flying Circus.

Installazione
- Due versioni disponibili: 2.7.X e 3.7.X (faremo riferimento alla seconda).
- Comprende l'utility **pip** che permette di installare package che aggiungono funzionalità al linguaggio.
- In particolar modo è suggerita l'installazione di ipython.
>$ pip install ipython

Differenze pratiche con Java
Per scrivere "Hello World" in **Java**:

<pre>
class HelloWorld {
    public static void main(String args[]) {
        System.out.println("Hello world!");
    }
}
</pre>

È necessario:
- definire una classe;
- dichiarare il prototipo di una funzione pubblica, statica e void;
- che ha come argomento un array di oggetti della classe String;
- che usa la classe System invocando il metodo di un suo campo statico.

Non sarebbe meglio...

> print('Hello world')

## API REST

![alt text](https://paypal.github.io/gimel/images/restapi.png "API REST Logo")

Il termine **REST** (**Re**presentational **S**tate **T**ransfer ) rappresenta un sistema di trasmissione di dati su **HTTP** senza ulteriori livelli. Il funzionamento prevede una struttura degli URL ben definita (atta a identificare univocamente una risorsa o un insieme di risorse) e l'utilizzo dei verbi HTTP specifici per il recupero di informazioni (**GET**), per la modifica (POST, PUT, PATCH, DELETE) e per altri scopi (OPTIONS, ecc.).
![Rest-API.png](https://miro.medium.com/max/724/1*ZM82raTAQrw1KUkHiwErqw.png)

Element (elemento) generico: http(s)://api.example.com/resources/item17

## API REST - Esempi

Element (elemento) generico: http(s)://api.example.com/resources/item17

Esempio pratico Directions API della Google Maps Platform:
https://maps.googleapis.com/maps/api/directions/json?origin=Roma&destination=Berlino&key=AIzaSyCTPkufBttRcfSkA9zPYgivrYs9QEhdEEU

Esempio pratico API di ATM:
https://giromilano.atm.it/TPPortalBackEnd/geodata/pois/stops/12400?lang=it

## JSON

![json.png](https://reblog0110.files.wordpress.com/2018/02/json-logo.png)

**JSON** (**J**ava**S**cript **O**bject **N**otation) è un semplice formato per lo scambio di dati. Per le persone è facile da leggere e scrivere, mentre per le macchine risulta facile da generare e analizzarne la sintassi.

JSON è basato su **due** strutture:
- **Dizionario**: un insieme di coppie nome/valore. In diversi linguaggi, questo è realizzato come un oggetto, un record, uno struct, un dizionario, una tabella hash, un elenco di chiavi o un array associativo.
- **Lista**: un elenco ordinato di valori. Nella maggior parte dei linguaggi questo si realizza con un array, un vettore, un elenco o una sequenza.

## JSON

Esempio
![json_struttura.png](https://codesthesia.net/cgbrera2017/lezioni/slides/lez6-visualizzazioni-transcodifiche/figs/json_struttura.png)

Per visualizzare la struttura logica dei dati si possono utilizzare anche software web based come il seguente:
[https://jsoneditoronline.org/](https://jsoneditoronline.org/)

## Infrastruttura
![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Overview_of_a_three-tier_application_vectorVersion.svg/800px-Overview_of_a_three-tier_application_vectorVersion.svg.png "Three Tier")

## Web Server
Tipicamente **Apache** o Nginx.

## Application Server
es. Tomcat/Jboss
Apache Tomcat (o semplicemente Tomcat) è un web server (nella forma di contenitore servlet) open source sviluppato dalla Apache Software Foundation.
In informatica WildFly, precedentemente noto come JBoss AS o semplicemente JBoss, è un application server open source che implementa le specifiche Java EE. WildFly è un sistema multipiattaforma, interamente realizzato in Java.

O semplicemente un **interprete** con o senza la sua virtual machine PHP, PVM/JVM.

## Database Server
MySQL (MariaDB), Postgres, Oracle, ecc.
MariaDB è un DBMS nato da un fork di MySQL creato dal programmatore originale di tale programma. Aperto ai contributi della comunità, l'area di sviluppo principale è lo storage engine Aria, precedentemente chiamato Maria da cui deriva MariaDB; si tratta di un'evoluzione di MyISAM.

Per i casi più semplici può essere sufficiente un file di testo oppure semplicemente una **API Rest**.

## Particolareggiamo
### Problema
Supponiamo di voler realizzare una WebApp che ci permetta di visualizzare (anche gradevolmente) i tempi di attesa (anche altre informazioni) dei mezzi dei superficie ATM.

Perché è un buon esempio?

- Uso gratuito.
- Non occorrono API Key (più semplice).
- Utile quotidianamente.
- E' possibile verificarne il funzionamento in tempo reale.

## Ingredienti
-	Linguaggio semplice e potente, particolarmente orientato al problem solving... **Python!**
-	Conoscenza dei linguaggi del WEB (HTML5, CSS3, Javascript, Ajax, …)... **ok!**
-	Conoscenza dell’architettura del WEB e rudimenti di reti (architettura Client Server, protocolli HTTP(S))... **ok!**
-	Fonti a pagamento oppure no (tramite analisi, scraping o quant’altro). Librerie per gestire i dati di scambio ([JSON](https://www.json.org/json-it.html), XML, CSV, custom...)... **analizziamo!**


-	Infrastruttura HW/SW (anche un semplice pc o SBPC come il raspberry) per l’erogazione del servizio... anche il computer di casa va bene... **ok!**

## Cuoco
Il programmatore che realizza l’algoritmo risolutivo tradotto in codice... ci siamo... **ok!**

## Analizziamo per recuperare la fonte dei dati (il nostro DB)

https://giromilano.atm.it/#/home/

https://giromilano.atm.it/TPPortalBackEnd/geodata/pois/stops/12400?lang=it

https://giromilano.atm.it/tpPortal/geodata/pois/3042198?lang=it data leak

## Git e github
Andiamo a scrivere le classi
https://github.com/pitfallharry/atm/

## Step
[Step1](https://atm.webapplication.me/step1/webapp.py)

- Impostiamo *manualmente* la fermata di test 12400.
"""

#!/usr/bin/python
# -*- coding: utf-8 -*-
import sys

print('Content-Type: text/html; charset=utf-8\n')
print('<!DOCTYPE html>\n<html>\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n<title>Atm</title>')
print('</head>\n<body>\n')

stops = ['12400']
from atm import Stop
for stop in stops:
    s = Stop(stop)
    s.waitmessage('html')
print('</body>\n</html>')

"""[Step2](https://atm.webapplication.me/step2/webapp.py)

- Aggiungiamo la funzione main (def).
- Abbelliamo con style.css e logo.png + favicon.ico
- Aggiungiamo la linea di test (es. 73)
"""

#!/usr/bin/python
# -*- coding: utf-8 -*-
import sys

print('Content-Type: text/html; charset=utf-8\n')
print('<!DOCTYPE html>\n<html>\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n<link rel="stylesheet" href="style.css">\n<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />\n<title>Atm</title>')
print('</head>\n<body>\n<img src="./logo.png" title="Logo ATM"><br>')

def main(argv):
    stops = ['12400']
    lines = ['73']
    from atm import Stop
    for stop in stops:
        s = Stop(stop)
        s.waitmessage('html')
    from atm import Line
    for line in lines:
        l = Line(line,'0')
        l.path('html')
    print('</body>\n</html>')

if __name__ == "__main__":
    main(sys.argv[1:])

"""[Step3](https://atm.webapplication.me/step3/webapp.py)
- Aggiungiamo la cattura dei parametri nella query string (tramite motodo GET - CGI).
- Aggiungiamo la logica di navigazione (classi **plus**). I numeri di fermate e linee diventano cliccabili.
- Spostiamo header e footer all'esterno del codice per *pulizia*.

[https://atm.webapplication.me/step3/webapp.py?s=12405,12402](https://smbit.it/atm/step3/webapp.py?s=12405,12402)
"""

#!/usr/bin/python
# -*- coding: utf-8 -*-
import os, sys, cgi
import header

def main(argv):
    stops = []
    lines = []
    direction = '0'
    form = cgi.FieldStorage()
    if form.getfirst("s"):
        from atm import Stop
        stops = form.getfirst("s").split(",")
    if form.getfirst("l"):
        from atm import Line
        lines = form.getfirst("l").split(",")
    if form.getfirst("d"):
        direction = form.getfirst("d")
    opposite_direction = str(1 - int(direction))
    for stop in stops:
        s = Stop(stop)
        s.waitmessage_plus(direction)
    for line in lines:
        l = Line(line,direction)
        l.path_plus(opposite_direction)
    import footer

if __name__ == "__main__":
    main(sys.argv[1:])

"""## Step 4 - Versione finale
[Step4](https://atm.webapplication.me/step4/webapp.py)
- abbelliamo il footer inserendo anche la buca di invio
- limite chiamate (numero fermate + numero linee) = 3
- impostazioni in file esterno settings
- inc/ monitoraggio e opengraph
"""

#!/usr/bin/python
# -*- coding: utf-8 -*-
''' ATM Milano command line checker '''
import os, sys, cgi
from settings import *
import header

def main(argv):
    stops = []
    lines = []
    direction = default_direction
    form = cgi.FieldStorage()
    if form.getfirst("s"):
        from atm import Stop
        stops = form.getfirst("s").split(",")
    if form.getfirst("l"):
        from atm import Line
        lines = form.getfirst("l").split(",")
    if form.getfirst("d"):
        direction = form.getfirst("d")
    opposite_direction = str(1 - int(direction))
    nargs=len(stops) + len(lines)
    if nargs > limit:
        print(msg_overlimit.format(nargs,limit))
    else:
        for stop in stops:
            s = Stop(stop)
            s.waitmessage_plus(direction)
        for line in lines:
            l = Line(line,direction)
            l.path_plus(opposite_direction)
    import footer

if __name__ == "__main__":
    main(sys.argv[1:])
